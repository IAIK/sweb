// Projectname: SWEB
// Simple operating system for educational purposes
//
// Copyright (C) 2005  Andreas Niederl
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.



/**
 * CVS Log Info for $RCSfile: List.tcpp,v $
 *
 * $Id: List.tcpp,v 1.7 2005/09/12 23:29:06 aniederl Exp $
 * $Log: List.tcpp,v $
 * Revision 1.6  2005/09/11 17:47:02  davrieb
 * add rotate()
 *
 * Revision 1.5  2005/09/11 11:31:34  davrieb
 * revert to previous revision
 *
 * Revision 1.3  2005/09/07 23:44:42  aniederl
 * changed constructor with default parameter to a separate default constructor and one (for actual usage) with parameter
 *
 * Revision 1.2  2005/09/07 23:13:01  aniederl
 * refined empty node handling in pop methods
 *
 * Revision 1.1  2005/05/26 01:08:37  aniederl
 * initial import of List, Queue and Stack data structures
 *
 */

/**
 * template definitions, included by List.h
 *
 */

#include "assert.h"

#ifndef Swap_Function___
#define Swap_Function___
// FIXXXME: don't know where to put that function
/**
 * swaps two elements
 * @param first the first element
 * @param second the second element
 *
 */
template<typename ValueType>
void swap(ValueType &first, ValueType &second)
{
  ValueType tmp = first;
  first = second;
  second = tmp;
}
#endif // Swap_Function___


//----------------------------------------------------------------------
/**
 * default constructor for class List
 * the node size will be set to a default value
 */
template<typename ValueType>
List<ValueType>::List() : first_node_(0),
                          last_node_(0),
                          number_of_elements_(0)
{

}


//----------------------------------------------------------------------
/**
 * copy constructor for class List
 * @param instance is a constant reference to an object of
 * type List
 */
template<typename ValueType>
List<ValueType>::List(const List<ValueType> &instance)
{
  number_of_elements_ = instance.number_of_elements_;

  // copy nodes
  ListNode<ValueType> *node = new ListNode<ValueType>(*instance.first_node_);

  first_node_ = node;

  while(node->hasNextNode())
  {
    ListNode<ValueType> *next_node = new ListNode<ValueType>(
      *(node->getNextNode()));

    next_node->setPreviousNode(node);
    node->setNextNode(next_node);

    node = next_node;
  }

  last_node_ = node;
}


//----------------------------------------------------------------------
/**
 * destructor for class List
 */
template<typename ValueType>
List<ValueType>::~List()
{
  while(first_node_)
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();
    delete first_node_;
    first_node_ = tmp;
  }
}


//----------------------------------------------------------------------
/**
 * = operator for class List
 * @param instance is a reference to a List object
 * @return is a reference to a List object
 */
template<typename ValueType>
List<ValueType>& List<ValueType>::operator = (const List<ValueType> &instance)
{
  List<ValueType> new_list(instance);

  swap(this->number_of_elements_, new_list.number_of_elements_);
  swap(this->first_node_, new_list.first_node_);
  swap(this->last_node_, new_list.last_node_);

  return (*this);
}

//----------------------------------------------------------------------
/**
 * returns the size (number of elements) of the list
 * @return the size (number of elements) of the list
 *
 */
template<typename ValueType>
typename List<ValueType>::size_type List<ValueType>::size() const
{
  return number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * checks, if the list is empty
 * @return true, if the list is empty
 *
 */
template<typename ValueType>
bool List<ValueType>::empty() const
{
  return (number_of_elements_ == 0);
}


//----------------------------------------------------------------------
/**
 * returns a reference to the element at the given index
 * @param index The index of the searched element
 * @return the element at the given index
 * @pre !empty() && index < size()
 *
 */
template<typename ValueType>
typename List<ValueType>::reference List<ValueType>::operator[](
  size_type index)
{
  assert(!empty() && index < size());

  ListNode<ValueType> *node = first_node_;

  if(index && node)
  {
    do
      node = node->getNextNode();
    while(--index && node);
  }

  assert(node);

  return node->getElement();
}


//----------------------------------------------------------------------
/**
 * returns a const reference to the element at the given index
 * @param index The index of the searched element
 * @return the element at the given index
 * @pre !empty() && index < size()
 *
 */
template<typename ValueType>
typename List<ValueType>::const_reference List<ValueType>::operator[](
  size_type index) const
{
  assert(!empty() && index < size());

  ListNode<ValueType> *node = first_node_;

  if(index && node)
  {
    do
      node = node->getNextNode();
    while(--index && node);
  }

  assert(node);

  return node->getElement();
}


//----------------------------------------------------------------------
/**
 * returns the first element
 * @return the first element
 * @pre !empty()
 *
 */
template<typename ValueType>
typename List<ValueType>::reference List<ValueType>::front()
{
  assert(!empty());

  return first_node_->getElement();
}


//----------------------------------------------------------------------
/**
 * returns the first element
 * @return the first element
 * @pre !empty()
 *
 */
template<typename ValueType>
typename List<ValueType>::const_reference List<ValueType>::front() const
{
  assert(!empty());

  return first_node_->getElement();
}


//----------------------------------------------------------------------
/**
 * returns the last element
 * @return the last element
 * @pre !empty()
 *
 */
template<typename ValueType>
typename List<ValueType>::reference List<ValueType>::back()
{
  assert(!empty());

  return last_node_->getElement();
}


//----------------------------------------------------------------------
/**
 * returns the last element
 * @return the last element
 * @pre !empty()
 *
 */
template<typename ValueType>
typename List<ValueType>::const_reference List<ValueType>::back() const
{
  assert(!empty());

  return last_node_->getElement();
}



//----------------------------------------------------------------------
/**
 * inserts an element at the end
 * @param element the new element to insert
 *
 */
template<typename ValueType>
void List<ValueType>::pushBack(const_reference element)
{
  ListNode<ValueType> *new_node = new ListNode<ValueType>(element);

  if(last_node_)
  {
    last_node_->setNextNode(new_node);
    new_node->setPreviousNode(last_node_);
    last_node_ = new_node;
  }
  else
    first_node_ = last_node_ = new_node;

  ++number_of_elements_;
}


//----------------------------------------------------------------------
/**
 * removes the last element
 *
 */
template<typename ValueType>
void List<ValueType>::popBack()
{
  if(!number_of_elements_)
    return;

  ListNode<ValueType> *last = last_node_->getPreviousNode();

  delete last_node_;

  --number_of_elements_;

  if(last)
    last_node_ = last;
  else
  {
    if(number_of_elements_)
      last_node_ = first_node_;
    else
      last_node_ = first_node_ = 0;
  }
}

//----------------------------------------------------------------------
/**
 * inserts an element at the front
 * @param element the new element to insert
 *
 */
template<typename ValueType>
void List<ValueType>::pushFront(const_reference element)
{
  ListNode<ValueType> *new_node = new ListNode<ValueType>(element);

  if(first_node_)
  {
    first_node_->setPreviousNode(new_node);
    new_node->setNextNode(first_node_);
    first_node_ = new_node;
  }
  else
    first_node_ = last_node_ = new_node;

  ++number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * removes the first element
 *
 */
template<typename ValueType>
void List<ValueType>::popFront()
{
  if(!number_of_elements_)
    return;

  ListNode<ValueType> *first = first_node_->getNextNode();

  delete first_node_;

  --number_of_elements_;

  if(first)
    first_node_ = first;
  else
  {
    if(number_of_elements_)
      first_node_ = last_node_;
    else
      first_node_ = last_node_ = 0;
  }
}

//----------------------------------------------------------------------
/**
 * inserts an element at the given index
 * NOTE that the index MUST be smaller than or equal to the size of the list
 * @param index the index at which to insert the element
 * @param element the element to insert
 *
 */
template<typename ValueType>
void List<ValueType>::insert(size_type index, const_reference element)
{
  if(index > number_of_elements_)
    return;

  ListNode<ValueType> *node = first_node_;
  ListNode<ValueType> *new_node = new ListNode<ValueType>(element);

  if(index && node)
  {
    do
      node = node->getNextNode();
    while(--index && node);
  }

  if(node)
  {
    new_node->setNextNode(node);
    new_node->setPreviousNode(node->getPreviousNode());
    node->getPreviousNode()->setNextNode(new_node);
    node->setPreviousNode(new_node);
  }
  else
  {
    if(last_node_)
    {
      last_node_->setNextNode(new_node);
      new_node->setPreviousNode(last_node_);

      last_node_ = new_node;
    }
    else
      first_node_ = last_node_ = new_node;
  }

  ++number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * removes an element at the given index
 * @param index the index of the element to remove
 *
 */
template<typename ValueType>
void List<ValueType>::remove(size_type index)
{
  if(index >= number_of_elements_)
    return;

  ListNode<ValueType> *node = first_node_;
  ListNode<ValueType> *next_node;
  ListNode<ValueType> *previous_node;

  if(index && node)
  {
    do
      node = node->getNextNode();
    while(--index && node);
  }

  assert(node);

  next_node = node->getNextNode();
  previous_node = node->getPreviousNode();

  if(previous_node)
    previous_node->setNextNode(next_node);
  else
    first_node_ = next_node;

  if(next_node)
    next_node->setPreviousNode(previous_node);
  else
    last_node_ = previous_node;

  delete node;

  --number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * swaps the contents of the list with the given list
 * @param list the list with which the contents are swapped
 *
 */
template<typename ValueType>
void List<ValueType>::swapList(List<ValueType> &list)
{
  swap(this->number_of_elements_, list.number_of_elements_);
  swap(this->first_node_, list.first_node_);
  swap(this->last_node_, list.last_node_);
}


//----------------------------------------------------------------------
/**
 * cleares the list
 *
 */
template<typename ValueType>
void List<ValueType>::clear()
{
  while(first_node_)
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();
    delete first_node_;
    first_node_ = tmp;
  }

  number_of_elements_ = 0;
}

//----------------------------------------------------------------------
/**
 * Removes the first element and adds it to the end.
 *
 */
template<typename ValueType>
void List<ValueType>::rotateBack()
{
  // this command is senseless with <= 1 elements in the list
  if(number_of_elements_ <= 1)
    return;

  ListNode<ValueType> *first = first_node_->getNextNode();
  first_node_->setNextNode(0);
  first->setPreviousNode(0);

  last_node_->setNextNode(first_node_);
  first_node_->setPreviousNode(last_node_);

  last_node_ = first_node_;
  first_node_ = first;
}

//----------------------------------------------------------------------
/**
 * Removes the last element and adds it to the front.
 *
 */
template<typename ValueType>
void List<ValueType>::rotateFront()
{
  // this command is senseless with <= 1 elements in the list
  if(number_of_elements_ <= 1)
    return;

  ListNode<ValueType> *last = last_node_->getPreviousNode();
  last_node_->setPreviousNode(0);
  last->setNextNode(0);

  first_node_->setPreviousNode(last_node_);
  last_node_->setNextNode(first_node_);

  first_node_ = last_node_;
  last_node_ = last;
}
