// Projectname: SWEB
// Simple operating system for educational purposes
//
// Copyright (C) 2005  Andreas Niederl
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.



/**
 * CVS Log Info for $RCSfile: List.tcpp,v $
 *
 * $Id: List.tcpp,v 1.1 2005/05/26 01:08:37 aniederl Exp $
 * $Log$
 */

/**
 * template definitions, included by List.h
 *
 */


#ifndef Swap_Function___
#define Swap_Function___
// FIXXXME: don't know where to put that function
/**
 * swaps two elements
 * @param first the first element
 * @param second the second element
 *
 */
template<typename ValueType>
void swap(ValueType &first, ValueType &second)
{
  ValueType tmp = first;
  first = second;
  second = tmp;
}
#endif // Swap_Function___

template<typename ValueType>
const typename List<ValueType>::size_type List<ValueType>::NODE_SIZE = 15;


//----------------------------------------------------------------------
/**
 * default constructor for class List
 * @param node_size the size of the list nodes
 */
template<typename ValueType>
List<ValueType>::List(size_type node_size)
 : node_size_(node_size),
   number_of_nodes_(2),
   number_of_elements_(0)
{
  // generate the two default nodes
  first_node_ = new ListNode<ValueType>(node_size_);
  last_node_ = new ListNode<ValueType>(node_size_);

  first_node_->setNextNode(last_node_);
  last_node_->setPreviousNode(first_node_);

  // set backward access for the first one
  first_node_->setBackwardAccess(true);
}


//----------------------------------------------------------------------
/**
 * copy constructor for class List
 * @param instance is a constant reference to an object of
 * type List
 */
template<typename ValueType>
List<ValueType>::List(const List<ValueType> &instance)
{
  node_size_ = instance.node_size_;
  number_of_nodes_ = instance.number_of_nodes_;
  number_of_elements_ = instance.number_of_elements_;


  // copy nodes
  ListNode<ValueType> *node = new ListNode<ValueType>(*instance.first_node_);

  first_node_ = node;

  while(node->hasNextNode())
  {
    ListNode<ValueType> *next_node = new ListNode<ValueType>(
      *(node->getNextNode()));

    next_node->setPreviousNode(node);
    node->setNextNode(next_node);

    node = next_node;
  }

  last_node_ = node;
}


//----------------------------------------------------------------------
/**
 * destructor for class List
 */
template<typename ValueType>
List<ValueType>::~List()
{
  while(first_node_)
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();
    delete first_node_;
    first_node_ = tmp;
  }
}


//----------------------------------------------------------------------
/**
 * = operator for class List
 * @param instance is a reference to a List object
 * @return is a reference to a List object
 */
template<typename ValueType>
List<ValueType>& List<ValueType>::operator = (const List<ValueType> &instance)
{
  List<ValueType> new_list(instance);

  swap(this->node_size_, new_list.node_size_);
  swap(this->number_of_nodes_, new_list.number_of_nodes_);
  swap(this->node_size_, new_list.node_size_);
  swap(this->number_of_elements_, new_list.number_of_elements_);
  swap(this->first_node_, new_list.first_node_);
  swap(this->last_node_, new_list.last_node_);

  return (*this);
}

//----------------------------------------------------------------------
/**
 * returns the size (number of elements) of the list
 * @return the size (number of elements) of the list
 *
 */
template<typename ValueType>
typename List<ValueType>::size_type List<ValueType>::size() const
{
  return number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * checks, if the list is empty
 * @return true, if the list is empty
 *
 */
template<typename ValueType>
bool List<ValueType>::empty() const
{
  return (number_of_elements_ == 0);
}


//----------------------------------------------------------------------
/**
 * returns a reference to the element at the given index
 * @param index The index of the searched element
 * @return the element at the given index
 *
 */
template<typename ValueType>
typename List<ValueType>::reference List<ValueType>::operator[](
  size_type index)
{
  ListNode<ValueType> *node = first_node_;
  size_type node_size = node->size();
  while(node->hasNextNode())
  {
    if(index < node_size)
      break;

    index -= node_size;
    node = node->getNextNode();
    node_size = node->size();
  }

  return node->get(index);
}


//----------------------------------------------------------------------
/**
 * returns a const reference to the element at the given index
 * @param index The index of the searched element
 * @return the element at the given index
 *
 */
template<typename ValueType>
typename List<ValueType>::const_reference List<ValueType>::operator[](
  size_type index) const
{
  ListNode<ValueType> *node = first_node_;
  size_type node_size = node->size();
  while(node->hasNextNode())
  {
    if(index < node_size)
      break;

    index -= node_size;
    node = node->getNextNode();
    node_size_ = node->size();
  }

  return node->get(index);
}


//----------------------------------------------------------------------
/**
 * returns the first element
 * @return the first element
 *
 */
template<typename ValueType>
typename List<ValueType>::reference List<ValueType>::front()
{
  if(first_node_->size())
    return first_node_->get(0);
  else
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();

    if(tmp)
      return tmp->get(0);
  }

  // FIXXXME bad workaround
  return first_node_->get(0);
}


//----------------------------------------------------------------------
/**
 * returns the first element
 * @return the first element
 *
 */
template<typename ValueType>
typename List<ValueType>::const_reference List<ValueType>::front() const
{
  if(first_node_->size())
    return first_node_->get(0);
  else
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();

    if(tmp)
      return tmp->get(0);
  }

  // FIXXXME bad workaround
  return first_node_->get(0);
}


//----------------------------------------------------------------------
/**
 * returns the last element
 * @return the last element
 *
 */
template<typename ValueType>
typename List<ValueType>::reference List<ValueType>::back()
{
  size_type node_size = last_node_->size();

  if(node_size)
    return last_node_->get(node_size - 1);
  else
  {
    ListNode<ValueType> *tmp = last_node_->getPreviousNode();
    node_size = tmp->size();

    if(node_size)
      return tmp->get(node_size - 1);
  }

  // FIXXXME bad workaround
  return last_node_->get(0);
}


//----------------------------------------------------------------------
/**
 * returns the last element
 * @return the last element
 *
 */
template<typename ValueType>
typename List<ValueType>::const_reference List<ValueType>::back() const
{
  size_type node_size = last_node_->size();

  if(node_size)
    return last_node_->get(node_size - 1);
  else
  {
    ListNode<ValueType> *tmp = last_node_->getPreviousNode();
    node_size = tmp->size();

    if(node_size)
      return tmp->get(node_size - 1);
  }

  // FIXXXME bad workaround
  return last_node_->get(0);
}



//----------------------------------------------------------------------
/**
 * inserts an element at the end
 * @param element the new element to insert
 *
 */
template<typename ValueType>
void List<ValueType>::pushBack(const_reference element)
{
  if(last_node_->full())
  {
    ListNode<ValueType> *tmp = new ListNode<ValueType>(node_size_);
    last_node_->setNextNode(tmp);
    tmp->setPreviousNode(last_node_);
    ++number_of_nodes_;

    last_node_ = tmp;
  }

  last_node_->append(element);
  ++number_of_elements_;
}


//----------------------------------------------------------------------
/**
 * removes the last element
 *
 */
template<typename ValueType>
void List<ValueType>::popBack()
{
  if(!number_of_elements_)
    return;

  size_type node_size = last_node_->size();

  // if last node is empty get hands on the previous node
  if(!node_size)
  {
    ListNode<ValueType> *tmp = last_node_->getPreviousNode();
    node_size = tmp->size();
    if(node_size)
    {
      tmp->remove(node_size - 1);
      --number_of_elements_;
    }
  }
  else
  {
    // remove last element
    last_node_->remove(node_size - 1);
    --number_of_elements_;
  }


  // if last node is empty and NOT the second node remove it
  if(last_node_->empty() &&
     (number_of_nodes_ > 2))
  {
    ListNode<ValueType> *tmp = last_node_->getPreviousNode();
    delete last_node_;
    --number_of_nodes_;

    tmp->setNextNode(0);
    last_node_ = tmp;
  }
}

//----------------------------------------------------------------------
/**
 * inserts an element at the front
 * @param element the new element to insert
 *
 */
template<typename ValueType>
void List<ValueType>::pushFront(const_reference element)
{
  // check if first node is full, if so generate a new one
  if(first_node_->full())
  {
    // set node to default (forward access) state
    first_node_->setBackwardAccess(false);

    // get a new node
    ListNode<ValueType> *tmp = new ListNode<ValueType>(node_size_);
    ++number_of_nodes_;

    first_node_->setPreviousNode(tmp);
    tmp->setNextNode(first_node_);

    first_node_ = tmp;

    // set backward access
    first_node_->setBackwardAccess(true);
  }

  first_node_->append(element);
  ++number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * removes the first element
 *
 */
template<typename ValueType>
void List<ValueType>::popFront()
{
  if(!number_of_elements_)
    return;

  if(first_node_->empty())
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();
    delete first_node_;
    --number_of_nodes_;

    first_node_ = tmp;
    first_node_->setBackwardAccess(true);

    if(number_of_nodes_ < 2)
    {
      last_node_ = new ListNode<ValueType>(node_size_);

      first_node_->setNextNode(last_node_);
      last_node_->setPreviousNode(first_node_);

      ++number_of_nodes_;
    }
  }

  first_node_->remove(0);
  --number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * inserts an element at the given index
 * NOTE that the index MUST be smaller than or equal to the size of the list
 * @param index the index at which to insert the element
 * @param element the element to insert
 *
 */
template<typename ValueType>
void List<ValueType>::insert(size_type index, const_reference element)
{
  if(index > number_of_elements_)
    return;

  ListNode<ValueType> *node = first_node_;
  size_type node_size = node->size();
  while(node->hasNextNode())
  {
    if(!index || index < node_size)
      break;

    index -= node_size;
    node = node->getNextNode();
    node_size = node->size();
  }

  if(node_size >= node_size_)
  {
    ListNode<ValueType> *tmp = new ListNode<ValueType>(node_size_);

    // split the node into two nodes
    if(index < (node_size_ / 2))
    {
      // top half gets a new node
      for(size_type node_index = index; node_index < node_size; ++node_index)
        tmp->append(node->get(node_index));

      if(node == first_node_)
        node->setBackwardAccess(false);

      size_type remove_counter = node_size - index;
      while(remove_counter-- > 0)
        node->remove(node->size() - 1);

      if(node == first_node_)
        node->setBackwardAccess(true);

      if(node == last_node_)
        last_node_ = tmp;
      else
        tmp->setNextNode(node->getNextNode());


      node->getNextNode()->setPreviousNode(tmp);
      tmp->setPreviousNode(node);
      node->setNextNode(tmp);
    }
    else
    {
      // bottom half gets a new node
      for(size_type node_index = 0; node_index < index; ++node_index)
        tmp->append(node->get(node_index));

      if(node != first_node_)
        node->setBackwardAccess(true);

      size_type remove_counter = index + 1;
      while(remove_counter-- > 0)
        node->remove(0);

      if(node != first_node_)
      {
        node->setBackwardAccess(false);

        tmp->setPreviousNode(node->getPreviousNode());
        node->getPreviousNode()->setNextNode(tmp);
      }
      else
      {
        first_node_ = tmp;
        tmp->setBackwardAccess(true);
        node->setBackwardAccess(false);
      }

      tmp->setNextNode(node);
      node->setPreviousNode(tmp);
    }

    ++number_of_nodes_;
  }

  node->insert(index, element);
  ++number_of_elements_;
}

//----------------------------------------------------------------------
/**
 * removes an element at the given index
 * @param index the index of the element to remove
 *
 */
template<typename ValueType>
void List<ValueType>::remove(size_type index)
{
  ListNode<ValueType> *node = first_node_;
  size_type node_size = node->size();
  while(node->hasNextNode())
  {
    if(index < node_size)
      break;

    index -= node_size;
    node = node->getNextNode();
    node_size = node->size();
  }

  node->remove(index);
  --number_of_elements_;

  // if the node size is less than the half of the initial size look for
  // a neighbour which has room for the elements
  // if one is found merge them
  size_type half_node_size = node_size_ / 2;
  if(number_of_nodes_ > 2 && (node->size() < half_node_size))
  {
    ListNode<ValueType> *tmp = node->getPreviousNode();

    if(tmp && (tmp->size() < half_node_size))
    {
      if(tmp == first_node_)
        tmp->setBackwardAccess(false);

      // copy elements
      for(size_type node_index = 0; node_index < node->size(); ++node_index)
        tmp->append(node->get(node_index));

      if(tmp == first_node_)
        tmp->setBackwardAccess(true);

      tmp->setNextNode(node->getNextNode());

      ListNode<ValueType> *next = node->getNextNode();
      if(next)
        next->setPreviousNode(tmp);

      delete node;

      node = tmp;
    }
    else
    {
      tmp = node->getNextNode();

      if(tmp && (tmp->size() < half_node_size))
      {
        tmp->setBackwardAccess(true);

        // copy elements
        size_type node_index = node->size();
        while(node_index > 0)
          tmp->append(node->get(--node_index));

        tmp->setBackwardAccess(false);

        tmp->setPreviousNode(node->getPreviousNode());

        ListNode<ValueType> *previous = node->getPreviousNode();
        if(previous)
          previous->setNextNode(tmp);

        delete node;

        node = tmp;
      }
    }

    // node is empty, remove it
    if(node->empty())
    {
      ListNode<ValueType> *tmp = node->getPreviousNode();

      if(tmp)
        tmp->setNextNode(node->getNextNode());
      else
        first_node_ = node->getNextNode();

      tmp = node->getNextNode();

      if(tmp)
        tmp->setPreviousNode(node->getPreviousNode());
      else
        last_node_ = node->getPreviousNode();

      delete node;
      --number_of_nodes_;
    }
  }
}

//----------------------------------------------------------------------
/**
 * swaps the contents of the list with the given list
 * @param list the list with which the contents are swapped
 *
 */
template<typename ValueType>
void List<ValueType>::swapList(List<ValueType> &list)
{
  swap(this->node_size_, list.node_size_);
  swap(this->number_of_nodes_, list.number_of_nodes_);
  swap(this->number_of_elements_, list.number_of_elements_);
  swap(this->first_node_, list.first_node_);
  swap(this->last_node_, list.last_node_);
}


//----------------------------------------------------------------------
/**
 * cleares the list
 *
 */
template<typename ValueType>
void List<ValueType>::clear()
{
  while(first_node_)
  {
    ListNode<ValueType> *tmp = first_node_->getNextNode();
    delete first_node_;
    first_node_ = first_node_->getNextNode();
  }

  // reset internal structure
  number_of_nodes_ = 2;
  number_of_elements_ = 0;

  // generate the two default nodes
  first_node_ = new ListNode<ValueType>(node_size_);
  last_node_ = new ListNode<ValueType>(node_size_);

  first_node_->setNextNode(last_node_);
  last_node_->setPreviousNode(first_node_);

  // set first node for backward access
  first_node_->setBackwardAccess(true);
}

