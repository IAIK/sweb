# https://www.airs.com/blog/archives/518
.section .note.GNU-stack,"",@progbits

# ok, this is our main interrupt handling stuff

.code32
.text

.equ KERNEL_DS, 0x10
.equ KERNEL_FS, 0x38
.equ KERNEL_GS, 0x38

.macro loadKernelSegments
  movw $KERNEL_DS, %ax
  movw %ax,%es
  movw %ax,%ds
  movw $KERNEL_FS, %ax
  movw %ax,%fs
  movw $KERNEL_GS, %ax
  movw %ax,%gs
.endm

.macro pushAll
  pushal
  push %ds
  push %es
  push %fs
  push %gs
  loadKernelSegments
.endm

.macro popAll
  pop %gs
  pop %fs
  pop %es
  pop %ds
  popal
.endm

.extern arch_saveThreadRegisters


/*
    Called by interrupt_entrystub<N>(), which pushes the interrupt number
    as well as a fake error code onto the stack if it wasn't generated by the cpu
*/
.global arch_interruptHandler
.type   arch_interruptHandler, @function
arch_interruptHandler:
    pushall
    movl %esp, %edx
    ## pushl %esp

    ## pushl $0
    ## call arch_saveThreadRegisters
    ## addl $8, %esp


    movl 56(%esp), %eax
    pushl %eax /* fake return address = rip at interrupt */
    /* set up fake call stack for debugger backtrace */
.global arch_interruptHandler_backtrace_fix
.type   arch_interruptHandler_backtrace_fix, @function
arch_interruptHandler_backtrace_fix:
	pushl %ebp
	movl %esp, %ebp

    pushl %edx /* address of saved registers */
    call genericInterruptEntry

    leave
    addl $4, %esp /* pop simulated return address */

    popall
    addl $8, %esp /* pop interrupt number and error code */
    iretl
    hlt
