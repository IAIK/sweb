/* https://www.airs.com/blog/archives/518 */
.section .note.GNU-stack,"",@progbits

.code64
.text

.extern arch_saveThreadRegisters
.extern genericInterruptHandler

.equ KERNEL_DS, 0x20

.macro swapgsIfPrivChange cs_offset=8
    testl $3, \cs_offset(%rsp)
    jz 1f

    /*
    # # debug write to emulator io console port
    # movw $0xE9, %dx
    # xorq %rax, %rax
    # movb 8(%rsp), %al
    # andl $3, %eax
    # addl $0x41, %eax
    # outb %al, %dx
    # hlt
    */

    swapgs
1:
.endm

.macro loadKernelSegments
  movw $KERNEL_DS, %ax
  movw %ax,%ss
  movw %ax,%ds
  movw %ax,%es
  /* movw %ax,%fs */
  /* movw %ax,%gs */
.endm

.macro pushAll
  pushq %rsp
  pushq %rax
  pushq %rcx
  pushq %rdx
  pushq %rbx
  pushq %rbp
  pushq %rsi
  pushq %rdi
  pushq %r8
  pushq %r9
  pushq %r10
  pushq %r11
  pushq %r12
  pushq %r13
  pushq %r14
  pushq %r15
  movw %es,%ax
  pushq %rax
  movw %ds,%ax
  pushq %rax

  /* push fs base */
  movq $0xC0000100, %rcx
  rdmsr
  pushq %rdx
  pushq %rax

  loadKernelSegments
.endm

.macro popAll

  /* pop fs base (only relevant when there's no contextSwitch) */
  movq $0xC0000100, %rcx
  popq %rax
  popq %rdx

  /* Only restore fs base when returning to user mode (user fs is thread specific, kernel fs is _CPU_ specific and changes depending on which cpu the thread is scheduled on, so the saved fs base is incorrect when the thread is re-scheduled on another cpu) */
  /* Test for user mode by looking at the privilege level of the data segment selector that's next on the stack */
  testl $3, (%rsp)
  jz 1f
  wrmsr
1:

  popq %rax
  movw %ax,%ds
  popq %rax
  movw %ax,%es
  popq %r15
  popq %r14
  popq %r13
  popq %r12
  popq %r11
  popq %r10
  popq %r9
  popq %r8
  popq %rdi
  popq %rsi
  popq %rbp
  popq %rbx
  popq %rdx
  popq %rcx
  popq %rax
  popq %rsp
.endm



/*
    Called by interrupt_entrystub<N>(), which pushes the interrupt number
    as well as a fake error code onto the stack if it wasn't generated by the cpu
*/
.global arch_interruptHandler
.type   arch_interruptHandler, @function
arch_interruptHandler:
    swapgsIfPrivChange 24
	pushAll

	movq %rsp, %rdi

	movq 176(%rsp), %rax /* rip at interrupt, depends on size of saved registers! */

	/* set up fake call stack for debugger backtrace */
	pushq %rax /* fake return address = rip at interrupt */
.global arch_interruptHandler_backtrace_fix
.type   arch_interruptHandler_backtrace_fix, @function
arch_interruptHandler_backtrace_fix:
	pushq %rbp
	movq %rsp, %rbp

    call genericInterruptEntry

    leave
    popq %rdx /* pop simulated return address */

	popAll
    addq $16, %rsp /* pop interrupt number and error code */

	swapgsIfPrivChange
	iretq
    hlt
